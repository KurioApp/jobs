<img src="logo-pt-kurio.png" alt="Logo" style="width: 200px;"/>

# Senior Backend Engineer

Kurio is a content aggregator. We're partnering with hundreds of publisher. As a backend engineer, you will be working with services that serves our users. We love for things to just work. We care about best practices. We appreciate people that keeps learning and share.

## The Backend Role

You will build and maintain production-level services. We mostly use **Golang**. We expect a good coding standard that results in good working software. As the engineering world evolves, we're constantly evolving too. Hence the need for fast-learners, to learn new technologies and share them among team members.

## What it's like working at PT Kurio

- We value people that keeps learning
- We appreciate the extra miles given
- All engineers have access to all of our repositories

## What you will do

- Build and maintain production-level services
  - APIs, along with its documentation
  - Pub/Sub
  - Deployment to staging and production environment
- Test-Driven Development: write unit and integration tests
- Scrum
  - Sprint planning
  - Daily standup
  - Sprint Review
  - Retrospective

## Qualifications

- Kurio's values (Get sh*t done, Be Bold, Stay Curious, Excellence, Collaboration)
- Deep knowledge on computer science (things like data structure, OOP)
- Golang
- Understand and able to build a RESTful API
- Experienced with SQL and NoSQL like MySQL and MongoDB (DynamoDB, Spanner, etc. is a plus)
- Deep knowledge on at least 1 programming language (i.e. Golang, Python, NodeJS)
- Familiar with at least one general-purpose/scripting language (i.e. Python, Node.js)
- Test-Driven Development (TDD)
- Experienced on building highly scalable systems
- Familiar with Git workflow and its principles
- Knowledge on DevOps practices

## Preferred qualifications

- Familiar with Node.js
- Knowledge on software architectures
- Knowledge in frequently used software architecture patterns (i.e. event-driven, publish-subscribe, scheduling, etc.)
- Knowledge in frequently used design patterns (i.e. repository pattern, factory method, singleton, dependency injection, etc.)
